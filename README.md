# B5-Assignment-2


1. What is PostgreSQL?
PostgreSQL একটি ওপেন-সোর্স, শক্তিশালী ও অবজেক্ট-রিলেশনাল ডেটাবেজ ম্যানেজমেন্ট সিস্টেম (ORDBMS)। এটি SQL ভাষাকে অনেক উন্নত বৈশিষ্ট্যের মাধ্যমে প্রসারিত করে, যেমন:

* জটিল কুয়েরি (Complex queries)
* ফরেন কী (Foreign keys)
* ট্রিগার (Triggers)
* আপডেটযোগ্য ভিউ (Updatable views)
* ট্রানজ্যাকশনাল ইন্টেগ্রিটি (Transactional integrity)
* মাল্টিভার্সন কনকারেন্সি কন্ট্রোল (MVCC)

PostgreSQL উভয় প্রকার ডেটা—গঠনযুক্ত (SQL) ও আধা-গঠনযুক্ত (JSON/XML)—সমর্থন করে। এটি মানসম্মততা (standards compliance), সম্প্রসারণযোগ্যতা (extensibility), এবং একটি শক্তিশালী কমিউনিটির জন্য পরিচিত। আপনি এতে নিজের ডেটা টাইপ, অপারেটর, অ্যাগ্রিগেট ফাংশন ইত্যাদি নিজেই সংজ্ঞায়িত করতে পারেন।

ব্যবহারিক উদাহরণ:
ধরুন আপনি একটি ওয়েব অ্যাপ তৈরি করছেন যেখানে ACID নীতিমালার ভিত্তিতে লেনদেন পরিচালনা করা দরকার—যেমন ব্যাংকিং সফটওয়্যার। PostgreSQL নিশ্চিত করে যে আপনার ডেটা থাকবে নিরাপদ এবং সঠিক।


2. What is the purpose of a database schema in PostgreSQL?

PostgreSQL-এ Schema হলো একটি লজিক্যাল কন্টেইনার বা নেমস্পেস যা ডেটাবেজের অবজেক্টগুলো (যেমন: টেবিল, ভিউ, ফাংশন, টাইপ, ইনডেক্স) সংরক্ষণ করে। এটি মূলত ডেটাকে গুছিয়ে রাখার এবং আলাদা করার একটি উপায়।

Schema ব্যবহারের উদ্দেশ্য:
একই ডেটাবেজের ভেতর যুক্তিসঙ্গতভাবে ডেটা সংগঠিত করা

নামের দ্বন্দ্ব (naming collision) এড়ানো – যেমন একই নামের দুটি টেবিল দুইটি আলাদা স্কিমায় রাখা

অনুমতি এবং অ্যাক্সেস নিয়ন্ত্রণ সহজভাবে পরিচালনা করা

মডুলার ডিজাইন এবং মাল্টি-টেন্যান্ট অ্যাপ্লিকেশন তৈরিতে সহায়তা করা

উদাহরণ (Example):
CREATE TABLE sales.orders (
    order_id SERIAL PRIMARY KEY,
    amount NUMERIC
);


3. Explain the Primary Key and Foreign Key concepts in PostgreSQL.

Primary Key একটি টেবিলের প্রতিটি রেকর্ড (row) কে ইউনিকভাবে চিহ্নিত করে। এটি:

* অবশ্যই ইউনিক (unique) মান ধারণ করতে হবে
* NULL হতে পারবে না
* অটোমেটিকভাবে একটি ইউনিক ইনডেক্স তৈরি করে

উদাহরণ (Example):
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name TEXT
);


এখানে `customer_id` হলো Primary Key, যা প্রতিটি গ্রাহককে (customer) ইউনিকভাবে শনাক্ত করবে।

Foreign Key (ফরেন কি)

Foreign Key হলো এমন একটি কলাম যা এক টেবিলকে অন্য টেবিলের সাথে সম্পর্কযুক্ত করে। এটি এক টেবিলের কলামকে অন্য টেবিলের **Primary Key**-র সাথে যুক্ত করে।

 উদাহরণ (Example):

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    order_date DATE
);


এখানে `customer_id` হলো একটি Foreign Key যা `orders` টেবিলকে `customers` টেবিলের সাথে সম্পর্কিত করে। অর্থাৎ, প্রতিটি অর্ডার অবশ্যই কোনো বৈধ কাস্টমারের সাথে যুক্ত থাকতে হবে।


 সংক্ষেপে সম্পর্ক:

* Primary Key: নিজ টেবিলে রেকর্ড ইউনিক রাখে
* Foreign Key: এক টেবিলের ডেটাকে অন্য টেবিলের সাথে সংযুক্ত করে, ডেটার ইন্টিগ্রিটি বজায় রাখে

> এই সম্পর্কের মাধ্যমে আপনি ডেটাবেজে একটি ভালোভাবে সংযুক্ত এবং সংগঠিত স্ট্রাকচার গড়ে তুলতে পারেন — যেটা বাস্তব বিশ্বের বিভিন্ন সম্পর্ককে সঠিকভাবে উপস্থাপন করে।


4. What is the difference between the `VARCHAR` and `CHAR` data types?

 `VARCHAR` এবং `CHAR` — উভয়ই ক্যারেক্টার স্ট্রিং সংরক্ষণে ব্যবহৃত হয়, তবে এগুলোর আচরণ ভিন্ন:

| বৈশিষ্ট্য (Feature)     | `VARCHAR(n)` – ভ্যারিয়েবল লেংথ স্ট্রিং | `CHAR(n)` – ফিক্সড লেংথ স্ট্রিং      |
| ----------------------- | --------------------------------------- | ------------------------------------ |
| অর্থ                | ভ্যারিয়েবল দৈর্ঘ্যের স্ট্রিং           | নির্দিষ্ট দৈর্ঘ্যের স্ট্রিং          |
| স্টোরেজ             | শুধুমাত্র ব্যবহৃত অক্ষর সংরক্ষণ করে     | অব্যবহৃত স্থান স্পেস দিয়ে ভরাট হয়   |
| দক্ষতা (Efficiency) | স্টোরেজে কম জায়গা নেয়                   | নির্দিষ্ট দৈর্ঘ্যের কারণে একটু দ্রুত |
| ব্যবহার             | `VARCHAR(50)` নামের মতো ডেটার জন্য      | `CHAR(2)` দেশের কোডের মতো ডেটার জন্য |



উদাহরণ (Example):

CREATE TABLE products (
    code CHAR(5),
    name VARCHAR(100)
);


এই টেবিলে:

* `code`: সর্বদা ঠিক ৫ অক্ষর সংরক্ষণ করবে। যদি আপনি `US` দেন, তাহলে এটা হবে `'US   '` (স্পেসসহ ৫ অক্ষর)।
* `name`: সর্বাধিক ১০০ অক্ষর পর্যন্ত চলমান দৈর্ঘ্যের টেক্সট সংরক্ষণ করতে পারবে। আপনি যদি ১০ অক্ষর লেখেন, তাহলে কেবল সেই ১০টিই সংরক্ষিত হবে।


কোনটা কখন ব্যবহার করবেন?

VARCHAR ব্যবহার করুন যখন স্ট্রিংয়ের দৈর্ঘ্য অজানা বা পরিবর্তনশীল হয় (যেমন: নাম, ঠিকানা)।
CHAR ব্যবহার করুন যখন সব ডেটার দৈর্ঘ্য নির্দিষ্ট এবং কম হয় (যেমন: দেশ কোড, স্টেট কোড, জেন্ডার ইত্যাদি)।

এই পার্থক্যগুলো বুঝে ব্যবহার করলে আপনি স্টোরেজ এবং পারফর্মেন্স দুইদিক থেকেই আপনার ডেটাবেজ অপ্টিমাইজ করতে পারবেন।


5. Explain the purpose of the `WHERE` clause in a `SELECT` statement.
 WHERE Clause — শর্ত অনুযায়ী রেকর্ড ফিল্টার করার জন্য ব্যবহৃত হয়।
WHERE ক্লজ এমন রেকর্ডগুলো বাছাই করে যা একটি নির্দিষ্ট শর্ত পূরণ করে। এটি ডেটা রিড করার সময় সঠিক/প্রাসঙ্গিক রো গুলোই রিটার্ন করে।

সিনট্যাক্স (Syntax):
SELECT * FROM employees
WHERE department = 'HR';

এই কোয়েরি কী করে?
এই কোয়েরিটি employees টেবিল থেকে শুধুমাত্র সেইসব এমপ্লয়ির তথ্য রিটার্ন করবে যাদের department কলামের মান ‘HR’।

অর্থাৎ, এটি একটি শর্তভিত্তিক অনুসন্ধান, যা অবাঞ্ছিত রো বাদ দিয়ে প্রাসঙ্গিক ডেটা এনে দেয়।

6. What are the `LIMIT` and `OFFSET` clauses used for?
LIMIT এবং OFFSET — ডেটা Pagination এবং Sampling এর জন্য অত্যন্ত গুরুত্বপূর্ণ SQL ক্লজ।
🔹 LIMIT:
ডেটাবেজ থেকে সর্বোচ্চ কতটি রো রিটার্ন করবে তা নির্ধারণ করে।

🔹 OFFSET:
ডেটাবেজ থেকে ফলাফল শুরুর আগে কতটি রো স্কিপ করবে তা নির্ধারণ করে।

উদাহরণ (Example):
SELECT * FROM products
ORDER BY product_id
LIMIT 10 OFFSET 20;

এই কোয়েরিটি কী করে?
product_id অনুযায়ী সব products সাজানো হবে

প্রথম ২০টি রো স্কিপ করা হবে (অর্থাৎ ১ম থেকে ২০তম রো বাদ যাবে)

তারপর পরবর্তী ১০টি রো (২১তম থেকে ৩০তম) রিটার্ন হবে

ব্যবহারিক প্রয়োগ (Use Case):
ওয়েব অ্যাপ্লিকেশনে pagination করতে ব্যবহৃত হয়, যেমন:

Page 1 → LIMIT 10 OFFSET 0

Page 2 → LIMIT 10 OFFSET 10

Page 3 → LIMIT 10 OFFSET 20

ইত্যাদি...

7. How can you modify data using `UPDATE` statements?
`UPDATE` স্টেটমেন্ট ব্যবহার করা হয় টেবিলের বিদ্যমান (existing) মান পরিবর্তন করতে।

সিনট্যাক্স (গঠন):

UPDATE table_name  
SET column1 = value1, column2 = value2  
WHERE condition;


উদাহরণ:

UPDATE employees  
SET salary = salary * 1.10  
WHERE department = 'Sales';


এই কোয়েরিটি কী করছে?
Sales বিভাগে কাজ করা সকল কর্মচারীর বেতন ১০% বাড়িয়ে দিচ্ছে।


সতর্কতা:

`WHERE` ক্লজ ব্যবহার না করলে টেবিলের সব রো আপডেট হয়ে যাবে, যা অনেক বড় সমস্যা তৈরি করতে পারে।

তাই সব সময় `WHERE` ব্যবহার করুন, যেন কেবল প্রয়োজনীয় রো-গুলোরই মান পরিবর্তন হয়।



8. What is the significance of the `JOIN` operation, and how does it work in PostgreSQL?
`JOIN` ব্যবহার করে একাধিক টেবিলের তথ্য একটি সম্পর্কিত কলামের (related column) মাধ্যমে একত্রে আনা যায়। এটি রিলেশনাল ডেটাবেসকে আরও শক্তিশালী ও স্কেলযোগ্য করে তোলে।

`JOIN`-এর ধরনসমূহ:

* INNER JOIN: শুধুমাত্র যেসব রো দুই টেবিলেই মিলে গেছে, সেগুলোই দেখায়
* LEFT JOIN: বাম দিকের টেবিলের সব রো দেখায় এবং ডান দিকের টেবিল থেকে মিল থাকলে সেই ডেটাও
* RIGHT JOIN: LEFT JOIN-এর উল্টো, ডান দিকের টেবিলের সব রো দেখায়
* FULL JOIN: দুই টেবিলের সব রো দেখায়, যেখানে মিল নেই সেখানে `NULL` দেখায়

উদাহরণ (INNER JOIN):

SELECT customers.name, orders.order_date
FROM customers
INNER JOIN orders ON customers.customer_id = orders.customer_id;


এই কোয়েরিটি কাস্টমারদের নাম ও তাদের অর্ডারের তারিখ দেখায়, যাদের অর্ডার রয়েছে।

`JOIN` হলো নর্মালাইজড টেবিলের মধ্যে সম্পর্ক স্থাপন করার উপায় এবং
মাল্টি-টেবিল কুয়েরি চালানোর জন্য অপরিহার্য।

9. Explain the `GROUP BY` clause and its role in aggregation operations.

`GROUP BY` ক্লজ ব্যবহার করে একই মানের রো গুলোকে গ্রুপ করা হয় এবং তার উপর `SUM`, `COUNT`, `AVG` ইত্যাদি aggregate function প্রয়োগ করা যায়।

 উদাহরণ:

SELECT department, AVG(salary)
FROM employees
GROUP BY department;

এই কুয়েরিটি প্রতিটি বিভাগের জন্য গড় বেতন নির্ণয় করে।

10. How can you calculate aggregate functions like `COUNT()`, `SUM()`, and `AVG()` in PostgreSQL?

Aggregate functions হল এমন ফাংশন যা একটি ডেটাসেটের উপরে গণনা করে ফলাফল দেয়:

* `COUNT()` – রো বা সারির সংখ্যা গণনা করে
* `SUM()` – সংখ্যামূলক মানগুলো যোগ করে
* `AVG()` – গড় মান নির্ণয় করে
* `MIN()`, `MAX()` – সর্বনিম্ন বা সর্বোচ্চ মান দেয়

উদাহরণ:
SELECT
    COUNT(*) AS total_employees,
    SUM(salary) AS total_salary,
    AVG(salary) AS average_salary
FROM employees;

এই কুয়েরিটি কর্মচারীদের সংখ্যা, মোট বেতন এবং গড় বেতন সম্পর্কে সারসংক্ষেপ তথ্য প্রদান করে।


